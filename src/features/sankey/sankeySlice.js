import { createAsyncThunk, createSlice,current } from '@reduxjs/toolkit';
import produce from "immer";
import { fetchSankeyAPI } from './sankeyAPI';

const initialState = {
  value: 0,
  sankeyData: {},
  status: 'idle'
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.

export const fetchSatForSankeyChart = createAsyncThunk(
  'sankey/fetchSankey',
  async (amount) => {   
    const response = await fetchSankeyAPI(amount);    
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

// immutability helpers
function insertItemImHelper(series, tempArray) {
  let series2 = Object.assign([], series);    
  let newSankeyData=  Object.assign([], series[0].data) ;  
       
  newSankeyData.push(tempArray);  
  let data = series2[0].data;  
  //const newData = [...data, tempArray];
  ///const newData = data.push(tempArray);  

  const newData = produce(data, draft => {
    draft.push(tempArray);
  });

  const newSeries = produce(series, ser => {
    ser[0].data = newData;
  });

  return newSeries;
}


export const sankeySlice = createSlice({
  name: 'sankey',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    increment: (state) => {
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    incrementByAmount: (state, action) => {
      state.value += action.payload;
    },
    updateSankeyData: (state, action) => {
      console.log(state.sankeyData);
      let currentState =  current(state);
      let { sankeyData , value } = current(state);   
      let tempArray =[];
      let formData1=Object.entries(action.payload.formData)
      for (var i = 0; i < formData1.length; i++) {
         tempArray.push(formData1[i][1]);
      }   
      state.sankeyData = produce(currentState.sankeyData, sank => {
        sank.series = insertItemImHelper(sankeyData.series, tempArray);
      });  
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetchSatForSankeyChart.pending, (state) => {     
        state.status = 'loading';
      })
      .addCase(fetchSatForSankeyChart.fulfilled, (state, action) => {
        state.status = 'idle';        
        state.sankeyData = action.payload;
        //state.value += action.payload;
      });
  },
});
export const { increment, decrement, incrementByAmount, updateSankeyData } = sankeySlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.sankey.value)`
// export const selectSankey = (state) => state.sankey.value;
export const selectSankey = (state) => {
  return state.sankey.sankeyData;
};

export const selectSankey2 = (state) => {
  return state.sankey;
};

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
export const setNewDataToSankey = (param, param2) => (dispatch, getState) => {
  const currentValue = selectSankey2(getState()); 
  //dispatch(updateSankeyData(currentValue, param));
};

export default sankeySlice.reducer;
